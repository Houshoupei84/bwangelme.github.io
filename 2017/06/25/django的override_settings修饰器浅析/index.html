<!DOCTYPE html>
<html lang="zh-Hans">
<head>

  <meta charset="utf-8" />

  
  <title>Django的override_settings修饰器浅析</title>

  
  
<link href="//cdn.jsdelivr.net" rel="dns-prefetch">
<link href="//at.alicdn.com" rel="dns-prefetch">
<link href="//fonts.googleapis.com" rel="dns-prefetch">
<link href="//fonts.gstatic.com" rel="dns-prefetch">



<link href="//www.google-analytics.com" rel="dns-prefetch">






<meta name="description" content="  Django的Settings模块代码说明 Django的override_settings修饰器分析  ">



<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@gohugoio">
<meta name="twitter:title" content="Django的override_settings修饰器浅析">
<meta name="twitter:description" content="  Django的Settings模块代码说明 Django的override_settings修饰器分析  ">
<meta name="twitter:image" content="/images/avatar.jpg">



<meta property="og:type" content="article">
<meta property="og:title" content="Django的override_settings修饰器浅析">
<meta property="og:description" content="  Django的Settings模块代码说明 Django的override_settings修饰器分析  ">
<meta property="og:url" content="/2017/06/25/django%E7%9A%84override_settings%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%B5%85%E6%9E%90/">
<meta property="og:image" content="/images/avatar.jpg">




<meta name="generator" content="Hugo 0.51">


<link rel="canonical" href="/2017/06/25/django%E7%9A%84override_settings%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%B5%85%E6%9E%90/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Keep Foolish">
<meta name="msapplication-tooltip" content="Keep Foolish">
<meta name='msapplication-navbutton-color' content="#5fbf5e">
<meta name="msapplication-TileColor" content="#5fbf5e">
<meta name="msapplication-TileImage" content="/images/tile-image-windows.png">
<link rel="icon" href="/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
<link rel="icon" sizes="192x192" href="/images/touch-icon-android.png">
<link rel="apple-touch-icon" href="/images/touch-icon-apple.png">


<link rel="preload" href="/styles/main.min.css" as="style">
<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="/images/avatar.jpg" as="image">
<link rel="preload" href="/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="/styles/main.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">


  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="/images/avatar.jpg" alt="Avatar">
  
  <h2 class="title">Keep Foolish</h2>
  
  <p class="subtitle">闻道百，以为莫己若者，我之谓也。</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="/">首页</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="/tags">标签</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="/about/">关于</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item"><a href="mailto:bwangel.me@gmail.com" title="Email"><span class="icon icon-email"></span></a></li><li class="social-item"><a href="//github.com/bwangelme" title="GitHub"><span class="icon icon-github"></span></a></li><li class="social-item"><a href="//weibo.com/3093227873" title="Weibo"><span class="icon icon-weibo"></span></a></li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">Django的override_settings修饰器浅析</h1>
      <p class="post-meta">@BWANGEL · 发表于 2017年6月25日 · 2 min read</p>
    </header>
    <article class="post-content"><blockquote>
<ol>
<li>Django的Settings模块代码说明</li>
<li>Django的<code>override_settings</code>修饰器分析</li>
</ol>
</blockquote>

<h2 id="前言">前言</h2>

<p>前两天刚刚看了Django settings的实现，今天又发现了测试工具中有个<code>override_settings</code>修饰器，于是就想从它下手来分析一下Django的<code>settings</code>。</p>

<p>本篇文章主要分析的是<code>override_settings</code>作为修饰器的实现，其作为上下文管理器的部分并未详细分析。</p>

<h2 id="django的settings说明">Django的settings说明</h2>

<p>在分析这个修饰器之前，我们先来了解一下Django的<code>settings</code>是如何实现的， Django的<code>settings</code>的代码存放在<code>django/conf/__init__.py</code>中，其中主要有三个类，<code>LazySettings</code>，<code>Settings</code>和<code>UserSettingsHolder</code>。</p>

<h3 id="settings">Settings</h3>

<p><code>Settings</code>类实现了Django配置的载入和存储功能，在它的<code>__init__</code>函数中，首先从<code>django/conf/global_settings.py</code>文件中导入Django默认的配置，然后再从<code>DJANGO_SETTINGS_MODULE</code>环境变量所指定的配置文件中导入我们项目自定义的配置，然后逐项地检查并添加配置。</p>

<p>需要注意的是，<code>Settings</code>会把我们自定义的配置的名称存放到<code>Settings._explicit_settings</code>集合中，<code>Settings.is_overriden</code>函数就是通过检查<code>Settings._explicit_settings</code>集合，来查看某项配置是否被我们自定义的配置给覆盖掉了。</p>

<h3 id="lazysettings">LazySettings</h3>

<p><code>LazySettings</code>是<code>Settings</code>类的一个代理，或者可以认为是对<code>Settings</code>的一层包裹，它的主要功能就是<code>Lazy</code>，或者叫做懒载入。它把<code>Settings</code>类的实例存放在它的私有变量<code>_wrapped</code>中，初始化的时候，它默认将<code>_wrapped</code>设置为空，只有当从<code>LazySettings</code>中取值的时候(会调用<code>LazySettings.__getattr__</code>函数)，它才会调用<code>_setup</code>函数，实例化一个<code>Settings</code>对象，并从中取出对应的配置项。</p>

<p>我们平常在代码中使用的<code>django.conf.settings</code>对象，就是这个类的实例。</p>

<h3 id="usersettingsholder">UserSettingsHolder</h3>

<p><code>UserSettingsHolder</code>类和上面两个类有些不同，它也是用来存储用户的配置项的，只不过它并不会从<code>django/conf/global_settings.py</code>文件中读取Django默认的配置，它只是单纯地将用户传入的配置存储起来，以供读取。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> __init__(self, default_settings):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Requests for configuration variables not in this class are satisfied
</span><span style="color:#e6db74">    from the module specified in default_settings (if possible).
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    self<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;_deleted&#39;</span>] <span style="color:#f92672">=</span> set()
    self<span style="color:#f92672">.</span>default_settings <span style="color:#f92672">=</span> default_settings</code></pre></div>
<p>上面就是<code>UserSettingsHolder</code>构造函数，从中我们可以看到，它接收一个<code>default_settings</code>参数，它主要就是从这个参数中获取并存储用户要设置的配置，并不存储Django默认的配置。</p>

<h2 id="override-settings修饰器的分析">override_settings修饰器的分析</h2>

<p>了解完Django的<code>settings</code>的实现以后，我们再来看一下<code>override_settings</code>修饰器。</p>

<p>我们在使用<code>override_settings</code>作为修饰器的时候，通常的形式是这样的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a6e22e">@override_settings</span>(DEBUG<span style="color:#f92672">=</span>False)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_some_feature</span>(self):
    <span style="color:#66d9ef">pass</span></code></pre></div>
<p>上面的代码中修饰器的部分，我们可以使用下面这种方式来理解它:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">test_some_feature <span style="color:#f92672">=</span> override_settings(DEBUG<span style="color:#f92672">=</span>False)(test_some_feature)</code></pre></div>
<p>从上面的形式可以看出，修饰器语法真正调用的是<code>override_settings</code>类的<code>__call__</code>方法，所以我们需要去关注一下<code>override_settings</code>的<code>__call__</code>方法。但是这个方法在<code>override_settings</code>类中并没有实现，它是在它的父类<code>TestContextDecorator</code>中实现的。</p>

<h3 id="testcontextdecorator">TestContextDecorator</h3>

<h4 id="call-方法"><code>__call__</code>方法</h4>

<p><code>TestContextDecorator</code>类的<code>__call__</code>方法如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> __call__(self, decorated):
    <span style="color:#66d9ef">if</span> isinstance(decorated, type):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>decorate_class(decorated)
    <span style="color:#66d9ef">elif</span> callable(decorated):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>decorate_callable(decorated)
    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#39;Cannot decorate object of type </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> type(decorated))</code></pre></div>
<p>从代码中我们可以看出，这个函数的功能主要就是对被修饰的对象进行了一下鉴别，如果修饰的是类，则调用<code>decorate_class</code>函数，如果修饰的是其他的可调用对象，则调用<code>decorate_callable</code>函数。</p>

<h4 id="decorate-class">decorate_class</h4>

<p>接着我们来看一下<code>decorate_class</code>函数，它的代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorate_class</span>(self, cls):
    <span style="color:#66d9ef">if</span> issubclass(cls, TestCase):
        decorated_setUp <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>setUp
        decorated_tearDown <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>tearDown

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setUp</span>(inner_self):
            <span style="color:#f92672">-&gt;</span> context <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>enable()
            <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>attr_name:
            <span style="color:#f92672">-&gt;</span>     setattr(inner_self, self<span style="color:#f92672">.</span>attr_name, context)
            decorated_setUp(inner_self)

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">tearDown</span>(inner_self):
            decorated_tearDown(inner_self)
            <span style="color:#f92672">-&gt;</span> self<span style="color:#f92672">.</span>disable()

        cls<span style="color:#f92672">.</span>setUp <span style="color:#f92672">=</span> setUp
        cls<span style="color:#f92672">.</span>tearDown <span style="color:#f92672">=</span> tearDown
        <span style="color:#66d9ef">return</span> cls
    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#39;Can only decorate subclasses of unittest.TestCase&#39;</span>)</code></pre></div>
<p>从上面的代码可以看出，<code>decorate_class</code>函数的针对<code>TestCase</code>类的<code>setUp</code>和<code>tearDown</code>函数添加了一些额外的代码，即我用<code>-&gt;</code>符号标记的部分。</p>

<p>这些代码的主要功能就是在<code>TestCase</code>类初始化的时候调用<code>TestContextDecorator.enable</code>函数，再以<code>self.attr_name</code>的值作为名称，把<code>enable</code>函数的返回值插入到<code>TestCase</code>类的实例中。同时在<code>TestCase</code>类销毁的时候调用<code>TestContextDecorator.disable</code>函数。</p>

<p>我们接着再去查看<code>TestContextDecorator.enable</code>和<code>TestContextDecorator.disable</code>函数，我们发现它们是在<code>override_settings</code>子类中实现的，那我们对于<code>decorate_class</code>的分析就到这里，<code>enable</code>和<code>disable</code>函数在后面分析到<code>override_settings</code>子类的时候会继续分析。</p>

<h4 id="decorate-callable">decorate_callable</h4>

<blockquote>
<p><strong>注意</strong>:
这个函数的代码涉及到了Python的上下文管理器(<code>with</code>语句)的部分知识，如果你可以自己动手写一个上下文管理器的话，继续阅读即可。
如果你对于上下文管理器还有些疑问的话，请参考我的另一篇文章: <a href="https://www.bwangel.me/2016/04/25/Python%E7%9A%84with%E8%AF%AD%E5%8F%A5/">PEP 343: Python的with语句</a></p>
</blockquote>

<p>分析完了<code>decorate_class</code>函数，我们接着回到<code>TestContextDecorator.__call__</code>方法，接着分析被修饰对象是可调用对象的那一种情况，也就是<code>TestContextDecorator.decorate_callable</code>函数。<code>decorate_callable</code>函数的代码如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorate_callable</span>(self, func):
    <span style="color:#a6e22e">@wraps</span>(func)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        <span style="color:#66d9ef">with</span> self <span style="color:#66d9ef">as</span> context:
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>kwarg_name:
                kwargs[self<span style="color:#f92672">.</span>kwarg_name] <span style="color:#f92672">=</span> context
            <span style="color:#66d9ef">return</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
    <span style="color:#66d9ef">return</span> inner</code></pre></div>
<p>可以看到，<code>decorate_callable</code>函数其实就是一个修饰器，它的主要功能就是将<code>TestContextDecorator</code>的实例作为一个上下文管理器进行了调用，需要注意的是，<code>return</code>语句是被包裹在<code>with</code>语句内的，也就是说，被修饰的函数执行完了以后，才会接着执行上下文管理器的<code>__exit__</code>函数。同时，它还会使用<code>self.kwarg_name</code>的值作为参数名字，将上下文管理器的返回值(也就是<code>__enter__</code>函数的返回值)传入被修饰的函数中。</p>

<p>既然<code>decorate_callable</code>将<code>TestContextDecorator</code>当做一个上下文管理器来使用，我们就需要关注一下它的<code>__enter__</code>和<code>__exit__</code>函数，这两个函数的代码如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> __enter__(self):
    <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>enable()

<span style="color:#66d9ef">def</span> __exit__(self, exc_type, exc_value, traceback):
    self<span style="color:#f92672">.</span>disable()</code></pre></div>
<p>可以看到，这两个函数的功能，基本上也是调用<code>enable</code>和<code>disable</code>函数。</p>

<h3 id="override-settings">override_settings</h3>

<p>分析完了<code>override_settings</code>的父类，我们接着来分析这个类本身。从上面的分析中我们可以看到，<code>override_settings</code>对于被修饰的类或者函数基本上就是做两件事，类或者函数初始化之前调用<code>enable</code>函数，并将<code>enable</code>函数的返回值传递到被修饰的类或者函数中。然后再在被修饰的类或者函数退出的时候调用<code>disable</code>函数。所以，我们将关注点集中到<code>override_settings</code>类的<code>enable</code>和<code>disable</code>函数上就好了。</p>

<p>首先来说<code>override_settings.enable</code>函数，它的代码如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enable</span>(self):
    <span style="color:#75715e"># Keep this code at the beginning to leave the settings unchanged</span>
    <span style="color:#75715e"># in case it raises an exception because INSTALLED_APPS is invalid.</span>
    <span style="color:#75715e"># 注意self.options其实就是`override_settings`类的构造函数中传入的关键字参数kwargs</span>
    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;INSTALLED_APPS&#39;</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>options:
        <span style="color:#66d9ef">try</span>:
            apps<span style="color:#f92672">.</span>set_installed_apps(self<span style="color:#f92672">.</span>options[<span style="color:#e6db74">&#39;INSTALLED_APPS&#39;</span>])
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span>:
            apps<span style="color:#f92672">.</span>unset_installed_apps()
            <span style="color:#66d9ef">raise</span>
    <span style="color:#75715e"># 这个settings._wrapped就是真实保存的设置</span>
    <span style="color:#75715e"># UserSettingsHolder就是</span>
    override <span style="color:#f92672">=</span> UserSettingsHolder(settings<span style="color:#f92672">.</span>_wrapped)
    <span style="color:#66d9ef">for</span> key, new_value <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>options<span style="color:#f92672">.</span>items():
        setattr(override, key, new_value)
    self<span style="color:#f92672">.</span>wrapped <span style="color:#f92672">=</span> settings<span style="color:#f92672">.</span>_wrapped
    settings<span style="color:#f92672">.</span>_wrapped <span style="color:#f92672">=</span> override
    <span style="color:#66d9ef">for</span> key, new_value <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>options<span style="color:#f92672">.</span>items():
        setting_changed<span style="color:#f92672">.</span>send(sender<span style="color:#f92672">=</span>settings<span style="color:#f92672">.</span>_wrapped<span style="color:#f92672">.</span>__class__,
                              setting<span style="color:#f92672">=</span>key, value<span style="color:#f92672">=</span>new_value, enter<span style="color:#f92672">=</span>True)</code></pre></div>
<p>可以看到<code>enable</code>函数的功能就是在原有的<code>settings</code>配置上，用我们在<code>options</code>中传入的配置覆盖掉原来的配置，并针对修改的配置项发出信号。同时将原来的配置保存到<code>self.wrapped</code>变量中。</p>

<p>接着我们再来看<code>override_settings.disable</code>函数，它的代码如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">disable</span>(self):
    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;INSTALLED_APPS&#39;</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>options:
        apps<span style="color:#f92672">.</span>unset_installed_apps()
    settings<span style="color:#f92672">.</span>_wrapped <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>wrapped
    <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>wrapped
    <span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>options:
        new_value <span style="color:#f92672">=</span> getattr(settings, key, None)
        setting_changed<span style="color:#f92672">.</span>send(sender<span style="color:#f92672">=</span>settings<span style="color:#f92672">.</span>_wrapped<span style="color:#f92672">.</span>__class__,
                              setting<span style="color:#f92672">=</span>key, value<span style="color:#f92672">=</span>new_value, enter<span style="color:#f92672">=</span>False)</code></pre></div>
<p>这个函数的功能也很简单，将<code>self.wrapped</code>中保存的配置还原，并针对更改的配置发出信号。</p>

<h2 id="总结">总结</h2>

<p>OK，至此，对于<code>override_settings</code>的分析就结束了，它的功能也比较简单，就是在一个作用域中修改配置，并在这个作用域结束的时候将配置还原，如果它修饰的作用域是一个函数的话，由于函数不像类有构造和析构函数，它就使用Python的上下文管理器来实现类的构造和析构函数的功能。</p></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="/tags/python"><span class="tag">Python</span></a></li>
        
          <li><a href="/tags/django"><span class="tag">Django</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        本博客所有文章除特别声明外，均采用 <a href='http://creativecommons.org/licenses/by-nc-sa/3.0/cn/' rel='external nofollow' target='_blank'>CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
      </p>
    </footer>
    
      <script src="https://utteranc.es/client.js"
        repo="bwangelme/blog-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
      
    
  </section>
  


<footer class="site-footer">
  <p>© 2017-2018 Keep Foolish</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo"
      target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="/scripts/index.min.js"></script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-89788711-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>






  </body>
</html>
